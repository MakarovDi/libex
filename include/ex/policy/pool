#ifndef EX_POLICY_POOL_H
#define EX_POLICY_POOL_H


#include <exception>
#include <cassert>
#include <vector>
#include <unordered_map>
#include <functional>

#include "ex/assert"


namespace ex
{
namespace policy
{

	template < class T >
	using creator = std::function<T&()>;


	// [-][+] doesn't destroy non-released objects (leaks possible)
	// [-]    double free possible
	// [-][+] allow releasing "foreign" objects (not from pool)
	// [-]    no asserts on: double free, releasing "foreign" object
	// [+]    fastest and lightweight
	template < class T >
	class ReleasedOnlyDestroy
	{
	protected:
		void creation_notice(T&)    {}
		void acquisition_notice(T&) {}
		void releasing_notice(T&)   {}

		void destroy(std::vector<T*>& released_list)
		{
			while (!released_list.empty())
			{
				T* object = released_list.back(); // no-throw
				released_list.pop_back();         // no-throw

				try
				{
					delete object;
				}
				catch(...)
				{
					FAILURE("<T> throws exception in destructor");
				}
			}
		}
	protected:
		ReleasedOnlyDestroy(uint32_t pool_depth)  {}
		~ReleasedOnlyDestroy() {}
	};


	// [+][-] destroy non-released objects (no leaks)
	// [+]    safe double release (no double free)
	// [-][+] allow releasing "foreign" objects (not from pool)
	// [-]    no asserts on: double free, releasing "foreign" object, destroy non-released object
	template < class T >
	class AllAllocatedDestroy
	{
	protected:
		void creation_notice(T& object)
		{
			m_death_note.push_back(&object);
		}

		void acquisition_notice(T&) {}
		void releasing_notice(T&)   {}

		void destroy(std::vector<T*>& released_list)
        {
            for (T* item : m_death_note)
            {
                try
                {
                    delete item;
                }
                catch(...)
                {
	                FAILURE("<T> throws exception in destructor");
                }
            }
        }
	protected:
		AllAllocatedDestroy(uint32_t pool_depth) { m_death_note.reserve(pool_depth); }
		~AllAllocatedDestroy() {}
	private:
		std::vector<T*> m_death_note;
	};


	// [*] same as AllAllocatedDestroy in RELEASE build
	// [+] has asserts in DEBUG build: double free, releasing "foreign" object, destroy non-released object
	// [-] heavy
	template < class T >
	class StrictAllAllocatedDestroy
	{
		enum : bool
		{
			kObjectIsInPool = true,
		};

	protected:
		void creation_notice(T& object)
		{
			auto result = m_death_note.insert(std::make_pair<T*, bool>(&object, kObjectIsInPool));

			ASSERT(result.second, "Object with same address already exists");
		}


		void acquisition_notice(T& object)
		{
			m_death_note[&object] = !kObjectIsInPool;
		}


		void releasing_notice(T& object)
		{
			auto object_pos = m_death_note.find(&object);

			ASSERT(object_pos != m_death_note.end(), "Was released \"foreign\" object (not from pool)");
			ASSERT(object_pos->second == !kObjectIsInPool, "Double release");

			m_death_note[&object] = kObjectIsInPool;
		}


		void destroy(std::vector<T*>& released_list)
		{
			for (auto& item : m_death_note)
			{
				ASSERT(item.second == kObjectIsInPool, "Pool object wasn't released");

                try
                {
                    delete item.first;
                }
                catch(...)
                {
	                FAILURE("<T> throws exception in destructor");
                }
			}
		}
	protected:
		StrictAllAllocatedDestroy(uint32_t pool_depth) { m_death_note.reserve(pool_depth); }
		~StrictAllAllocatedDestroy() {}
	private:
		std::unordered_map<T*, bool> m_death_note;
	};


	template < class T >
	class FixedSizePool
	{
	protected:
		T& extend_pool()
		{
			throw std::logic_error("fixed-size pool is empty");
		}
	protected:
		FixedSizePool(creator<T>)  {}
		~FixedSizePool()           {}
	};


	template < class T >
	class ExtendablePool
	{
	protected:
		T& extend_pool()
		{
			return m_creator();
		}
	protected:
		ExtendablePool(creator<T> function) : m_creator(std::move(function)) {}
		~ExtendablePool() {}
	private:
		creator<T> m_creator;
	};

}
}


#endif // EX_POLICY_POOL_H
