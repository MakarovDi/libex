#ifndef    EX_STRING_HEADER
#   define EX_STRING_HEADER


#include <string>
#include <memory>
#include <sstream>

//
// Note: module for maintain encoding-independent projects
//
// Using:
//
//      const Char* test = L("Some Text");
//
//      It will translated in dependent of UNICODE definition.
//
//      UNICODE undefined:
//
//      ->  const char* test = "Some Text";
//
//      UNICODE defined:
//
//      ->  const wchar_t* test = L"Some Text";
//
//  References:
//      docs/const_func/Compile-time computations - Andrzej's C++ blog.pdf
//      docs/schurr_cpp11_tools_for_class_authors.pdf, p.24
//


// Generates universal unicode defenition
#if defined(UNICODE) || defined(_UNICODE)
#   undef  UNICODE
#   define UNICODE
#endif


#ifdef L
#   undef L
#   warning "L macro already defined -> undef"
#endif




#ifdef UNICODE
#  define __L(s) L##s
#else
#  define __L(s) s
#endif

// L - conversion to project's encoding
#define L(S)    __L(S)


namespace ex
{

    // Char - char-type which depends on project's encoding
#ifdef UNICODE
    using Char = wchar_t;
#else
    using Char = char;
#endif


    // C++ strings
    using StringA  = std::string;
    using StringW  = std::wstring;
    using String   = std::basic_string<Char>;


    // C++ string streams
    using StringStreamA = std::stringstream;
    using StringStreamW = std::wstringstream;
    using StringStream  = std::basic_stringstream<Char>;


    // C-like safe strings
    using CStringA = std::unique_ptr<char[]>;
    using CStringW = std::unique_ptr<wchar_t[]>;
    using CString  = std::unique_ptr<Char[]>;


    namespace string
    {
        constexpr const Char* empty = L("");  // represent empty string

        //
        // Note: compile-time string constant selection based on template parameter
        //
        // Usage:
        //
        //  void log_message(const Char* message)
        //  {
        //      const Char* format = select<Char>("[MSG] %s", L"[MSG] %s");
        //
        //      print(format, message);
        //  }
        //

        template <typename CharType>
        constexpr const CharType* select(const char* const_str, const wchar_t* wide_const_str);

        template <>
        constexpr const char* select<char>(const char* const_str, const wchar_t*)
        {
            return const_str;
        }

        template <>
        constexpr const wchar_t* select<wchar_t>(const char*, const wchar_t* wide_const_str)
        {
            return wide_const_str;
        }
    }


    //
    // Note: compile-time string constant with selection between wide and usual options
    //
    // Usage:
    //
    //    static constexpr UniversalConstString exclamation_char("!", L"!");
    //
    //    String exclamation(const Char* message)
    //    {
    //        String str = String(message) + exclamation_char.select<Char>();
    //        return str;
    //    }
    //

    class UniversalConstString
    {
    public:
        constexpr UniversalConstString(const char* const_str, const wchar_t* wide_const_str) :
            m_const_str(const_str),
            m_wide_const_str(wide_const_str)
        {
        }

        template <typename CharType>
        constexpr const CharType* select() const
        {
            return string::select<CharType>(m_const_str, m_wide_const_str);
        }

    private:
        const char*    m_const_str;
        const wchar_t* m_wide_const_str;
    };


    // unit tests

    //    static constexpr ex::UniversalConstString exclamation_char("!", L"!");
    //
    //    // correctness
    //    static_assert(std::is_same<decltype(exclamation_char.select<wchar_t>()), const wchar_t*>::value, "failed");
    //    static_assert(std::is_same<decltype(exclamation_char.select<char>()), const char*>::value, "failed");
    //
    //    // compile-time work
    //    static_assert(exclamation_char.select<wchar_t>() != nullptr, "failed");
    //    static_assert(exclamation_char.select<char>()    != nullptr, "failed");
}


#endif