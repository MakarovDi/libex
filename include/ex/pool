#ifndef EX_MEM_POOL_H
#define EX_MEM_POOL_H


#include <cstdint>
#include <utility>

#include "interface"
#include "policy/pool"
#include "policy/threading"


namespace ex
{

#ifdef NDEBUG
    template < class T >
    using DefaultDestroyPolicy = policy::AllAllocatedDestroy<T>;
#else
    template < class T >
    using DefaultDestroyPolicy = policy::StrictAllAllocatedDestroy<T>;
#endif

    template
    <
        class T,
        class ThreadedModel = policy::SingleThreadModel,
        template <class> class DestroyPolicy   = DefaultDestroyPolicy,
        template <class> class ExtendingPolicy = policy::ExtendablePool
        // TODO: creation policy (allocator)
    >
    class ObjectPool final : private INonCopyable,
        protected ThreadedModel,
        protected DestroyPolicy<T>,
        protected ExtendingPolicy<T>

    {
        template < typename U >
        using shared = typename ThreadedModel::template shared<U>;
    public:

        explicit ObjectPool(uint32_t depth) :
            DestroyPolicy<T>(depth),
            ExtendingPolicy<T>(std::bind(&ObjectPool::create_object, this))
        {
            if (!depth)
                throw std::invalid_argument("depth must not be 0");

            reserve(depth);
        }


        ~ObjectPool()
        {
            this->destroy(m_pool_objects);
        }


        // throws
        T& acquire()
        {
            typename ThreadedModel::Lock guard;

            T* object;

            if (m_pool_objects.empty())
            {
                object = &this->extend_pool();
                ++m_depth;
            }
            else
            {
                object = m_pool_objects.back();
                m_pool_objects.pop_back();
            }

            this->acquisition_notice(*object);

            return *object;
        }


        // throws
        void release(T& t)
        {
            typename ThreadedModel::Lock guard;

            m_pool_objects.push_back(&t);

            this->releasing_notice(t);
        }

        // no-throw
        uint32_t depth() const { return m_depth; }

        // no-throw
        uint32_t available() const
        {
            typename ThreadedModel::Lock guard;

            return uint32_t(m_pool_objects.size());
        }

        // no-throw
        bool empty() const
        {
            typename ThreadedModel::Lock guard;

            return m_pool_objects.empty();
        }


        ObjectPool(ObjectPool&&) = default;
        ObjectPool& operator=(ObjectPool&&) = default;
    private:
        T& create_object()
        {
            T* object = new T();

            this->creation_notice(*object);

            return *object;
        }


        void reserve(uint32_t count)
        {
            m_pool_objects.reserve(count);

            count -= m_pool_objects.size();

            while (count--)
                m_pool_objects.push_back(&create_object());

            m_depth = m_pool_objects.size();
        }
    private:
        std::vector<T*>  m_pool_objects;
        shared<uint32_t> m_depth;
    };

}


#endif // EX_MEM_POOL_H
