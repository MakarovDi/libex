#ifndef    EX_ABSTRACT_HEADER
#   define EX_ABSTRACT_HEADER


#include "ex/format"

//
// Usage:
//
//      module.hpp:
//
//          namespace module
//          {
//          	extern std::unique_ptr<ILogger> logger;
//              ...
//
//      module.cpp:
//
//          namespace module
//          {
//          	std::unique_ptr<ILogger> logger(new NullLogger());
//              ...
//
//
//      main.cpp:
//
//          #include "module.hpp"
//
//          ...
//
//          module.logger.reset(new MyFileLogger());  // class MyFileLogger : public ILogger
//
//

namespace ex
{

    class ILogger
    {
    public:
        enum LoggingLevel : int
        {
            SILENT    = 0,
            ERRORS    = 1,
            WARNINGS  = 2,
            VERBOSE   = 3, // ERRORS + WARNINGS + INFO
            PARANOID  = 4, // ALL
        };


        virtual ~ILogger() {};


        explicit ILogger(LoggingLevel logging_level = WARNINGS) :
            m_logging_level(logging_level)
        {
        }


        template <typename CharType, typename... ArgTypes>
        void error(const CharType* tag, const CharType* format, const ArgTypes& ... args)
        {
            log_message(MessageType::ERROR, tag, format, args...);
        }


        template <typename CharType, typename... ArgTypes>
        void warning(const CharType* tag, const CharType* format, const ArgTypes& ... args)
        {
            log_message(MessageType::WARNING, tag, format, args...);
        }


        template <typename CharType, typename... ArgTypes>
        void info(const CharType* tag, const CharType* format, const ArgTypes& ... args)
        {
            log_message(MessageType::INFO, tag, format, args...);
        }


        template <typename CharType, typename... ArgTypes>
        void trace(const CharType* tag, const CharType* format, const ArgTypes& ... args)
        {
            log_message(MessageType::TRACE, tag, format, args...);
        }

    protected:
        enum MessageType
        {
            ERROR   = 1,
            WARNING = 2,
            INFO    = 3,
            TRACE   = 4,  // DEBUG

            TYPE_COUNT,
        };

        virtual void output(MessageType, const char*    message) = 0;
        virtual void output(MessageType, const wchar_t* message) = 0;

    private:
        template <typename CharType, typename... ArgTypes>
        void log_message(MessageType type, const CharType* tag, const CharType* format, const ArgTypes& ... args)
        {
            char_type_assert<CharType>();

            if (m_logging_level < LoggingLevel(type)) return;

            auto& writer = select_writer<CharType>();

            const CharType* prefix = select_prefix<CharType>(type);

            writer.write(prefix, tag);
            writer.write(format, args ...);

            output(type, writer.c_str());

            writer.clear();
        }


        template <typename CharType>
        static void char_type_assert()
        {
            static_assert(std::is_same<CharType, char>::value || std::is_same<CharType, wchar_t>::value,
                          "Only [char] or [wchar_t] allowed as CharType");
        }



        template <typename T>
        struct TypeHolder { typedef T type; };


        template <typename CharType>
        fmt::BasicMemoryWriter<CharType>& select_writer()
        {
            return select_writer(TypeHolder<CharType>());
        }

        fmt::BasicMemoryWriter<char>&    select_writer(TypeHolder<char>)    { return m_writer_a; }
        fmt::BasicMemoryWriter<wchar_t>& select_writer(TypeHolder<wchar_t>) { return m_writer_w; }



        template <typename CharType, class Dummy=int>
        struct TypeOrder;

        template <class Dummy>
        struct TypeOrder<char, Dummy>    { constexpr static int index = 0; };

        template <class Dummy>
        struct TypeOrder<wchar_t, Dummy> { constexpr static int index = 1; };


        template <typename CharType>
        static const CharType* select_prefix(MessageType type)
        {
            static const void* prefixes[MessageType::TYPE_COUNT][2] =
            {
                 { "",     L""     }, // 0 index isn't used
                 { "E {}", L"E {}" },
                 { "W {}", L"W {}" },
                 { "I {}", L"I {}" },
                 { "T {}", L"T {}" },
            };

            return static_cast<const CharType*>( prefixes[int(type)][TypeOrder<CharType>::index] );
        }

    private:
        int m_logging_level;

        fmt::MemoryWriter  m_writer_a;
        fmt::WMemoryWriter m_writer_w;
    };



    class NullLogger final : public ILogger
    {
    protected:
        virtual void output(MessageType, const char*    message) override { }
        virtual void output(MessageType, const wchar_t* message) override { }
    };

}

#endif
