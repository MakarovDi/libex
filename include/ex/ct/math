#ifndef     EX_CT_MATH_H
#   define  EX_CT_MATH_H


#include <stdexcept>

//
// Note: this functions can be used as compile-time constants:
//
//      static_assert(contains_char(__FILE__, '.'));
//      std::array<int, ct::factorial(10)> c_str;
//
// References:
//   https://akrzemi1.wordpress.com/2011/05/06/compile-time-computations
//   docs/const_func/Compile-time computations - Andrzej's C++ blog.pdf
//   docs/schurr_cpp11_tools_for_class_authors.pdf, p.24
//


namespace ex
{
namespace ct
{
    namespace require
    {
        //
        // Note: functions throws logic_exceptions, use for eliminate ambiguity
        //

        template <typename NumType>
        constexpr NumType nonnegative(NumType i)
        {
            return (i >= 0) ? i : throw std::logic_error("must be non negative");
        }

    }


    namespace unsafe
    {
        // unsafe: unsafe::factorial(-4) -> 1
        template <typename NumType>
        constexpr NumType factorial(NumType i)
        {
            return (i > 1) ? i * unsafe::factorial(i - 1) : 1;
        }
    }



    template <typename NumType>
    constexpr NumType factorial(NumType i)
    {
        return require::nonnegative(i), unsafe::factorial(i);
    }


    template <typename NumType>
    constexpr NumType abs(NumType x)
    {
        return x < 0 ? -x : x;
    }


    template <typename NumType>
    constexpr NumType min(NumType a, NumType b)
    {
        return a < b ? a : b;
    }


    template <typename NumType>
    constexpr NumType max(NumType a, NumType b)
    {
        return a > b ? a : b;
    }



//  [unit tests]

//    static_assert(ct::abs(-1) == 1);
//    static_assert(ct::abs(1) == 1);
//    static_assert(ct::abs(1.0) == 1.0);
//    static_assert(ct::abs(-1.0) == 1.0);
//
//    static_assert(ct::factorial(0) == 1);
//    static_assert(ct::factorial(1) == 1);
//    static_assert(ct::factorial(2) == 2);
//    static_assert(ct::factorial(4) == 2*3*4);
//    static_assert(ct::factorial(4.0) == 2.0*3.0*4.0);

}
}


#endif
