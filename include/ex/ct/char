#ifndef    EX_CT_CHAR_H
#   define EX_CT_CHAR_H


#include <cstdint>
#include <limits>


//
// Note: compile-time char-related operations
//


namespace ex
{
namespace ct
{
    constexpr static const size_t npos = std::numeric_limits<size_t>::max();


    namespace unsafe
    {
        //
        // Note: functions with some using limitations or ambiguity
        //


        // unsafe: contains_char("abc", 0) -> false (wrong semantic)
        //         contains_char(nullptr, <any>) -> crash
        template < typename CharType, size_t N >
        constexpr bool contains_char(const CharType (& str)[N], CharType c)
        {
            return *str == 0 ? false : *str == c ? true : unsafe::contains_char(str + 1, c);
        }
    }


    template <size_t index, typename CharType, size_t N>
    constexpr CharType char_at(const CharType (&str)[N])
    {
        return str[index];
    }


    template <typename CharType, size_t N>
    constexpr bool contains_char(const CharType (&str)[N], CharType c)
    {
        return c == 0 ? true : unsafe::contains_char(str, c);
    }


    template <typename CharType, size_t N>
    constexpr size_t strrchr(const CharType (&str)[N], CharType c, size_t offset = N - 1)
    {
        return offset == 0      ? ct::npos :
               str[offset] == c ? offset   : strrchr(str, c, offset - 1);

    }


    template <typename CharType, size_t N>
    constexpr size_t strlchr(const CharType (&str)[N], CharType c, size_t offset = 0)
    {
        return offset == N - 1  ? ct::npos :
               str[offset] == c ? offset   : strlchr(str, c, offset + 1);
    }

}
}

#endif
