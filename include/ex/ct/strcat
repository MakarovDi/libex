#ifndef    EX_CT_STRCAT_H
#   define EX_CT_STRCAT_H


#include "ex/ct/meta_str"

//
// Note: compile-time string concatenation
//


namespace ex
{
namespace ct
{


    template<typename CharType, size_t N1, size_t N2, size_t... indexes1, size_t... indexes2>
    constexpr auto strcat(const CharType (&str1)[N1],
                          const CharType (&str2)[N2],
                          meta::integer_sequence<indexes1...>,
                          meta::integer_sequence<indexes2...>)
        -> meta_str_type<CharType, indexes1..., sizeof...(indexes1) + indexes2...>
    {
        return { str1[indexes1]..., str2[indexes2]... };
    }


    template<typename CharType, size_t N1, size_t N2>
    constexpr auto strcat(const CharType (&str1)[N1], const CharType (&str2)[N2])
        -> decltype(strcat(str1, str2,
                           meta::make_integer_sequence<N1 - 1>(),
                           meta::make_integer_sequence<N2 - 1>()))
    {
        return strcat(str1, str2,
                      meta::make_integer_sequence<N1 - 1>(),
                      meta::make_integer_sequence<N2 - 1>());
    }


    template<typename CharType, size_t... indexes1, size_t... indexes2>
    constexpr auto operator+(meta_str_type<CharType, indexes1...> a,
                             meta_str_type<CharType, indexes2...> b)
        -> decltype(strcat(a.c_str, b.c_str))
    {
        return strcat(a.c_str, b.c_str);
    }


    template<typename CharType, size_t... indexes, size_t N>
    constexpr auto operator+(meta_str_type<CharType, indexes...> metastr, const CharType (&str)[N])
        -> decltype(metastr + meta_str(str))
    {
        return strcat(metastr.c_str, str);
    }


    template<typename CharType, size_t... indexes, size_t N>
    constexpr auto operator+(const CharType (&str)[N], meta_str_type<CharType, indexes...> metastr)
        -> decltype(metastr + meta_str(str))
    {
        return strcat(str, metastr.c_str);
    }

}
}


#endif
