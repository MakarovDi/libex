#ifndef	   EX_CONST_FUNC_HEADER
#	define EX_CONST_FUNC_HEADER


#include <exception>

//
// Note: this functions can be used as compile-time constants:
//
//      static_assert(contains_char(__FILE__), '.');
//      std::array<int, const_fun::factorial(10)> data;
//
// References: 
//   https://akrzemi1.wordpress.com/2011/05/06/compile-time-computations
//   docs/const_func/Compile-time computations - Andrzej's C++ blog.pdf
//

namespace ex
{
namespace ct // compile-time
{

    namespace unsafe
    {
        //
        // Note: functions with some using limitations or ambiguity
        //

        // unsafe: contains_char("abc", 0) -> false (wrong semantic)
        //         contains_char(nullptr, <any>) -> crash
        template <typename CharType>
        constexpr bool contains_char(const CharType* str, CharType c)
        {
            return *str == 0 ? false :
                   *str == c ? true  : unsafe::contains_char(str + 1, c);
        }


        // unsafe: strlchr(nullptr, <any>) -> crash
        template <typename CharType>
        constexpr const CharType* strlchr(const CharType* path, CharType c)
        {
            return *path == 0 ? nullptr :
                   *path == c ? path    : unsafe::strlchr(path + 1, c);
        }


        // unsafe: strrchr("abc", '*') -> "abc" (wrong semantic)
        //         strrchr("abc", 'b') -> "c"   (wrong semantic)
        template <typename CharType>
        constexpr const CharType* strrchr(const CharType* path, CharType c)
        {
            return unsafe::strlchr(path, c) == nullptr ? path :
                   unsafe::strrchr(unsafe::strlchr(path, c) + 1, c);
        }


        // unsafe: unsafe_factorial(-4) -> 1
        template <typename NumType>
        constexpr NumType factorial(NumType i)
        {
            return (i > 1) ? i * unsafe::factorial(i - 1) : 1;
        }
    }


    namespace require
    {
        //
        // Note: functions throws logic_exceptions, use for eliminate ambiguity
        //

        template <typename NumType>
        constexpr NumType nonnegative(NumType i)
        {
            return (i >= 0) ? i : throw std::logic_error("must be non negative");
        }


        template <typename Type>
        constexpr const Type* notnull(const Type* value)
        {
            return (value != nullptr) ? value : throw std::logic_error("must be not null");
        }
    }


    template <typename NumType>
    constexpr NumType factorial(NumType i)
    {
        return require::nonnegative(i), unsafe::factorial(i);
    }


    template <typename CharType>
    constexpr const CharType* strlchr(const CharType* str, CharType c)
    {
        return str == nullptr ? nullptr : unsafe::strlchr(str, c);
    }


    template <typename CharType>
    constexpr const CharType* strrchr(const CharType* str, CharType c)
    {
        return require::notnull(str),
               unsafe::strlchr(str, c) == nullptr ? nullptr : unsafe::strrchr(str, c) - 1;
    }


    template <typename CharType>
    constexpr bool contains_char(const CharType* str, CharType c)
    {
        return require::notnull(str),
               c == 0 ? true : unsafe::contains_char(str, c);
    }


    template <typename CharType>
    constexpr const CharType* basename(const CharType* path, CharType sep1, CharType sep2)
    {
        return require::notnull(path),
               ct::strrchr(path, sep1) != nullptr ? ct::strrchr(path, sep1) + 1 :
               ct::strrchr(path, sep2) != nullptr ? ct::strrchr(path, sep2) + 1 :
               path;
    }

    constexpr const char* basename(const char* path)
    {
        return basename(path, '\\', '/');
    }

    constexpr const wchar_t* basename(const wchar_t* path)
    {
        return basename(path, L'\\', L'/');
    }


//    // unit tests
//    inline void _unit_tests()
//    {
//        // check compile-time mode
//        static_assert(const_fun::strlchr("test", 't') != nullptr, "");
//        static_assert(const_fun::strlchr(L"test", L't') != nullptr, "");
//
//        static_assert(const_fun::strrchr("test", 't') != nullptr, "");
//        static_assert(const_fun::strrchr(L"test", L't') != nullptr, "");
//
//        static_assert(const_fun::contains_char("test", 'e'), "");
//        static_assert(const_fun::contains_char(L"test", L'e'), "");
//
//        static_assert(const_fun::basename("dev/test/base.cpp"), "");
//        static_assert(const_fun::basename(L"dev\\test\\base.cpp"), "");
//
//
//        const char* path1 = "dev/test/base.cpp";
//        const wchar_t* path11 = L"dev/test/base.cpp";
//        const char* path2 = "D:\\dev\\test\\base.cpp";
//        const wchar_t* path21 = L"D:\\dev\\test\\base.cpp";
//        const char* path3 = "base.cpp";
//        assert(const_fun::basename(path1) == path1 + 9);
//        assert(const_fun::basename(path11) == path11 + 9);
//        assert(const_fun::basename(path2) == path2 + 12);
//        assert(const_fun::basename(path21) == path21 + 12);
//        assert(const_fun::basename(path3) == path3);
//
//
////        std::array<int, const_fun::factorial(3)> test;
//
//        // check semantic
//        const char* test1 = "test";
//        const wchar_t* test2 = L"test";
//
//        assert(const_fun::strlchr(test1, 't') == test1);
//        assert(const_fun::strlchr(test2, L't') == test2);
//        assert(const_fun::strlchr(test1, 'd') == nullptr);
//        assert(const_fun::strlchr(test1, '\0') == nullptr);
//
//        assert(const_fun::strrchr(test1, 't') == test1 + 3);
//        assert(const_fun::strrchr(test2, L't') == test2 + 3);
//        assert(const_fun::strrchr(test1, 'd') == nullptr);
//        assert(const_fun::strrchr(test1, '\0') == nullptr);
//
//        assert(const_fun::contains_char(test1, 't'));
//        assert(const_fun::contains_char(test2, L't'));
//        assert(!const_fun::contains_char(test1, 'd'));
//        assert(const_fun::contains_char(test1, '\0'));
//    }
}
}
#endif
