#ifndef	   EX_CT_STRING_H
#	define EX_CT_STRING_H


#include <stdexcept>
#include <cstdint>
#include <limits>

#include "ex/meta"
#include "ex/ct/meta_str"


//
// Note: this functions can be used as compile-time constants:
//
//      static_assert(contains_char(__FILE__, '.'));
//      std::array<int, ct::factorial(10)> c_str;
//
// References: 
//   https://akrzemi1.wordpress.com/2011/05/06/compile-time-computations
//   docs/const_func/Compile-time computations - Andrzej's C++ blog.pdf
//   docs/schurr_cpp11_tools_for_class_authors.pdf, p.24
//

namespace ex
{
namespace ct // compile-time
{
    constexpr static const size_t npos = std::numeric_limits<size_t>::max();


    // string related functions //


    namespace unsafe
    {
        //
        // Note: functions with some using limitations or ambiguity
        //

        // unsafe: contains_char("abc", 0) -> false (wrong semantic)
        //         contains_char(nullptr, <any>) -> crash
        template <typename CharType, size_t N>
        constexpr bool contains_char(const CharType (&str)[N], CharType c)
        {
            return *str == 0 ? false :
                   *str == c ? true  : unsafe::contains_char(str + 1, c);
        }

        // unsafe: streq("Test", "Tst", 0) -> compilation error, streq("Test", "Test", 100) -> true
        template <typename CharType, size_t N>
        constexpr bool streq(const CharType (&str1)[N], const CharType (&str2)[N], size_t char_ofs)
        {
            return char_ofs >= N                    ? true  :
                   str1[char_ofs] != str2[char_ofs] ? false :
                   unsafe::streq<CharType>(str1, str2, char_ofs + 1);
        }
    }


    template <typename CharType, size_t N>
    constexpr bool contains_char(const CharType (&str)[N], CharType c)
    {
        return c == 0 ? true : unsafe::contains_char(str, c);
    }


    template <typename CharType, size_t N>
    constexpr size_t strlen(const CharType (&str)[N])
    {
        return N - 1;
    }


    template <size_t index, typename CharType, size_t N>
    constexpr CharType char_at(const CharType (&str)[N])
    {
        return str[index];
    }


    template <typename CharType, size_t N>
    constexpr bool streq(const CharType (&str1)[N], const CharType (&str2)[N])
    {
        return unsafe::streq<CharType>(str1, str2, 0);
    }

    template <typename CharType, size_t N1, size_t N2>
    constexpr bool streq(const CharType (&str1)[N1], const CharType (&str2)[N2])
    {
        return false;
    }


    template <typename CharType, size_t N>
    constexpr size_t strrchr(const CharType (&str)[N], CharType c, size_t offset = N - 1)
    {
        return offset == 0      ? ct::npos :
               str[offset] == c ? offset   : strrchr(str, c, offset - 1);

    }


    template <typename CharType, size_t N>
    constexpr size_t strlchr(const CharType (&str)[N], CharType c, size_t offset = 0)
    {
        return offset == N - 1  ? ct::npos :
               str[offset] == c ? offset   : strlchr(str, c, offset + 1);
    }


    template <size_t offset, typename CharType, size_t N>
    constexpr auto substr(const CharType (&str)[N])
        -> decltype( create_meta_str(str, meta::make_integer_sequence<N-1, offset>{}) )
    {
        return ct::create_meta_str(str, meta::make_integer_sequence<N-1, offset>{});
    }



//    // unit tests

//    inline void _unit_tests()
//    {
//        static_assert(substr<2>("Test") == "st");
//        static_assert(substr<2>(L"Test") == L"st");
//
//        static_assert(strlchr("test", 't') == 0);
//        static_assert(strlchr("test", 'a') == ct::npos);
//        static_assert(strlchr("", 'a') == ct::npos);
//
//        static_assert(strlchr(L"test", L't') == 0);
//        static_assert(strlchr(L"test", L'a') == ct::npos);
//        static_assert(strlchr(L"", L'a') == ct::npos);
//
//        static_assert(strrchr("test", 't') == 3);
//        static_assert(strrchr("test", 'a') == ct::npos);
//        static_assert(strrchr("", 'a') == ct::npos);
//
//        static_assert(strrchr(L"test", L't') == 3);
//        static_assert(strrchr(L"test", L'a') == ct::npos);
//        static_assert(strrchr(L"", L'a') == ct::npos);
//
//
//        static_assert(ct::streq("Test", "Test"));
//        static_assert(!ct::streq("Test", "Tost"));
//        static_assert(!ct::streq("Test", "Tst"));
//        static_assert(ct::streq("", ""));
//
//        static_assert(ct::streq(L"Test", L"Test"));
//        static_assert(!ct::streq(L"Test", L"Tost"));
//        static_assert(!ct::streq(L"Test", L"Tst"));
//        static_assert(ct::streq(L"", L""));
//
//        static_assert(const_fun::contains_char("test", 'e'), "");
//        static_assert(const_fun::contains_char(L"test", L'e'), "");
//
//        static_assert(char_at<2>("123") == '3', "char_at failure");
//        static_assert(char_at<2>(L"123") == L'3', "char_at failure");
//
//        static_assert(strlen("123") == 3, "failure");
//        static_assert(strlen("") == 0, "failure");
//        static_assert(strlen(L"123") == 3, "failure");
//        static_assert(strlen(L"") == 0, "failure");
//
//        assert(const_fun::contains_char(test1, 't'));
//        assert(const_fun::contains_char(test2, L't'));
//        assert(!const_fun::contains_char(test1, 'd'));
//        assert(const_fun::contains_char(test1, '\0'));
//    }


}
}


#endif
