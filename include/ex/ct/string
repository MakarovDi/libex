#ifndef	   EX_CONST_FUNC_HEADER
#	define EX_CONST_FUNC_HEADER


#include <stdexcept>
#include <cstdint>

//
// Note: this functions can be used as compile-time constants:
//
//      static_assert(contains_char(__FILE__, '.'));
//      std::array<int, ct::factorial(10)> c_str;
//
// References: 
//   https://akrzemi1.wordpress.com/2011/05/06/compile-time-computations
//   docs/const_func/Compile-time computations - Andrzej's C++ blog.pdf
//   docs/schurr_cpp11_tools_for_class_authors.pdf, p.24
//

namespace ex
{
namespace ct // compile-time
{

    namespace unsafe
    {
        //
        // Note: functions with some using limitations or ambiguity
        //

        // unsafe: contains_char("abc", 0) -> false (wrong semantic)
        //         contains_char(nullptr, <any>) -> crash
        template <typename CharType, size_t N>
        constexpr bool contains_char(const CharType (&str)[N], CharType c)
        {
            return *str == 0 ? false :
                   *str == c ? true  : unsafe::contains_char(str + 1, c);
        }

        // unsafe: streq("Test", "Tst", 0) -> compilation error, streq("Test", "Test", 100) -> true
        template <typename CharType, size_t N>
        constexpr bool streq(const CharType (&str1)[N], const CharType (&str2)[N], size_t char_ofs)
        {
            return char_ofs >= N ? true :
                   str1[char_ofs] != str2[char_ofs] ? false :
                   unsafe::streq<CharType>(str1, str2, char_ofs + 1);
        }
    }


    template <typename CharType, size_t N>
    constexpr bool contains_char(const CharType (&str)[N], CharType c)
    {
        return c == 0 ? true : unsafe::contains_char(str, c);
    }


    template <typename CharType, size_t N>
    constexpr size_t strlen(const CharType (&str)[N])
    {
        return N - 1;
    }


    template <size_t index, typename CharType, size_t N>
    constexpr CharType char_at(const CharType (&str)[N])
    {
        return str[index];
    }


    template <typename CharType, size_t N>
    constexpr bool streq(const CharType (&str1)[N], const CharType (&str2)[N])
    {
        return unsafe::streq<CharType>(str1, str2, 0);
    }

    template <typename CharType, size_t N1, size_t N2>
    constexpr bool streq(const CharType (&str1)[N1], const CharType (&str2)[N2])
    {
        return false;
    }


//    // unit tests

//    inline void _unit_tests()
//    {

//
//        // check compile-time mode
//        static_assert(const_fun::strlchr("test", 't') != nullptr, "");
//        static_assert(const_fun::strlchr(L"test", L't') != nullptr, "");
//
//        static_assert(const_fun::strrchr("test", 't') != nullptr, "");
//        static_assert(const_fun::strrchr(L"test", L't') != nullptr, "");
//
//        static_assert(const_fun::basename("dev/test/base.cpp"), "");
//        static_assert(const_fun::basename(L"dev\\test\\base.cpp"), "");
//
//
//        const char* path1 = "dev/test/base.cpp";
//        const wchar_t* path11 = L"dev/test/base.cpp";
//        const char* path2 = "D:\\dev\\test\\base.cpp";
//        const wchar_t* path21 = L"D:\\dev\\test\\base.cpp";
//        const char* path3 = "base.cpp";
//        assert(const_fun::basename(path1) == path1 + 9);
//        assert(const_fun::basename(path11) == path11 + 9);
//        assert(const_fun::basename(path2) == path2 + 12);
//        assert(const_fun::basename(path21) == path21 + 12);
//        assert(const_fun::basename(path3) == path3);
//
//
//        // check semantic
//        const char* test1 = "test";
//        const wchar_t* test2 = L"test";
//
//        assert(const_fun::strlchr(test1, 't') == test1);
//        assert(const_fun::strlchr(test2, L't') == test2);
//        assert(const_fun::strlchr(test1, 'd') == nullptr);
//        assert(const_fun::strlchr(test1, '\0') == nullptr);
//
//        assert(const_fun::strrchr(test1, 't') == test1 + 3);
//        assert(const_fun::strrchr(test2, L't') == test2 + 3);
//        assert(const_fun::strrchr(test1, 'd') == nullptr);
//        assert(const_fun::strrchr(test1, '\0') == nullptr);
//

//        static_assert(ct::streq("Test", "Test"));
//        static_assert(!ct::streq("Test", "Tost"));
//        static_assert(!ct::streq("Test", "Tst"));
//        static_assert(ct::streq("", ""));
//
//        static_assert(ct::streq(L"Test", L"Test"));
//        static_assert(!ct::streq(L"Test", L"Tost"));
//        static_assert(!ct::streq(L"Test", L"Tst"));
//        static_assert(ct::streq(L"", L""));

//        static_assert(const_fun::contains_char("test", 'e'), "");
//        static_assert(const_fun::contains_char(L"test", L'e'), "");

//        static_assert(char_at<2>("123") == '3', "char_at failure");
//        static_assert(char_at<2>(L"123") == L'3', "char_at failure");

//        static_assert(strlen("123") == 3, "failure");
//        static_assert(strlen("") == 0, "failure");
//        static_assert(strlen(L"123") == 3, "failure");
//        static_assert(strlen(L"") == 0, "failure");
//
//        assert(const_fun::contains_char(test1, 't'));
//        assert(const_fun::contains_char(test2, L't'));
//        assert(!const_fun::contains_char(test1, 'd'));
//        assert(const_fun::contains_char(test1, '\0'));
//    }
}
}
#endif
