#ifndef	   EX_CT_STRING_H
#	define EX_CT_STRING_H


#include "ex/ct/meta_str"
#include "ex/ct/char"
#include "ex/ct/charset"
#include "ex/ct/strcat"
#include "ex/ct/streq"
#include "ex/ct/strfill"


//
// Note: compile-time string operations
//
//
// Usage:
//
//     1. static_assert(contains_char(__FILE__, '.'));
//
//     2. constexpr static const auto kModuleTag = "[" + ct::basename(__FILE__) + "]";
//                ...
//        log.warning(kModuleTag, "warning: ", ...);
//
//     3. constexpr static const auto kString = ct::meta_str("qwerty") + "1234567890" + ...;
//
//
// References: 
//   https://akrzemi1.wordpress.com/2011/05/06/compile-time-computations
//   docs/const_func/Compile-time computations - Andrzej's C++ blog.pdf
//   docs/schurr_cpp11_tools_for_class_authors.pdf, p.24
//

namespace ex
{
namespace ct // compile-time
{
    // TODO: fix for strpad'ed string

    template <typename CharType, size_t N>
    constexpr size_t strlen(const CharType (&str)[N])
    {
        return N - 1;
    }


    namespace internal
    {

        template <size_t index>
        struct basename_iterator
        {
            // TODO: handle_char in C++14 without strpad
            // TODO: C++14 decltype(auto)


            template <typename CharType, size_t N>
            constexpr static auto handle_char(const CharType (& path)[N])
                -> decltype(ct::meta_str(path))
            {
                return path[index] == ct::charset::slash<CharType>()               ||
                       path[index] == ct::charset::back_slash<CharType>()           ?
                       ct::substr<index+1>(path) + ct::strpad<CharType, index+1>()  :
                       basename_iterator<index - 1>::handle_char(path);
            }

        };

        template <>
        struct basename_iterator<size_t(-1)>
        {
            template <typename CharType, size_t N>
            constexpr static auto handle_char(const CharType (&path)[N])
                -> decltype(ct::meta_str(path))
            {
                return ct::meta_str(path);
            }
        };

    }


    //
    // Usage:
    //
    //      static constexpr auto fname = ct::basename("test/file.c");
    //
    //      std::cout << fname;
    //      std::printf(fname);
    //
    // WARN: please use it as template argument or as [static] only!
    //
    //      0. static constexpr auto fname = ct::basename("test/file.c")
    //
    //                lea     rcx, _ZZ4mainE5fname ; "file.c"
    //                call    _ZL6printfPKcz_constprop_2 ; printf(char const*,...) [clone]
    //                mov     rcx, cs:_refptr__ZSt4cout
    //                lea     rdx, _ZZ4mainE5fname ; "file.c"
    //                call    _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc ; std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const*)
    //
    //
    //      1. constexpr auto fname = ct::basename("test/file.c")  !!! BEWARE !!!
    //
    //                lea     rbx, [rsp+38h+var_18]
    //                mov     rcx, rbx
    //                mov     [rsp+38h+var_18], 66h
    //                mov     [rsp+38h+var_17], 69h
    //                mov     [rsp+38h+var_16], 6Ch
    //                mov     [rsp+38h+var_15], 65h
    //                mov     [rsp+38h+var_14], 2Eh
    //                mov     [rsp+38h+var_13], 63h
    //                mov     [rsp+38h+var_12], 0
    //                mov     [rsp+38h+var_11], 0
    //                mov     [rsp+38h+var_10], 0
    //                mov     [rsp+38h+var_F], 0
    //                mov     [rsp+38h+var_E], 0
    //                mov     [rsp+38h+var_D], 0
    //                call    __printf ; printf(char const*,...)
    //
    //      2. std::cout << ct::basename("Test/main.cpp")   !!! BEWARE !!!
    //
    //                lea     rdx, aTestMain_cpp ; "Test/main.cpp"
    //                mov     rcx, rbx
    //                call    _ex_internal__basename_iterator__test_charILy14EEEDTcl8meta_strfp_EERAT__Kc  ; RECURSION!!!
    //                mov     rcx, cs:_refptr__ZSt4cout
    //                mov     rdx, rbx
    //                call    _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc ; std::operator<<<std::char_traits<char>>(std::basic_ostream<char,std::char_traits<char>> &,char const*)
    //
    //

    template <typename CharType, size_t N>
    constexpr auto basename(const CharType (&path)[N])
        -> decltype(ct::meta_str<CharType>(path))
    {
        return internal::basename_iterator<N - 2>::handle_char(path);
    }



}
}

//    [unit tests]

//    inline void _unit_tests()
//    {
//        static_assert(substr<2>("Test") == "st");
//        static_assert(substr<2>(L"Test") == L"st");
//
//        static_assert(ct::streq("Test", "Test"));
//        static_assert(!ct::streq("Test", "Tost"));
//        static_assert(!ct::streq("Test", "Tst"));
//        static_assert(ct::streq("", ""));
//
//        static_assert(ct::streq(L"Test", L"Test"));
//        static_assert(!ct::streq(L"Test", L"Tost"));
//        static_assert(!ct::streq(L"Test", L"Tst"));
//        static_assert(ct::streq(L"", L""));
//
//        static_assert(strlen("123") == 3, "failure");
//        static_assert(strlen("") == 0, "failure");
//        static_assert(strlen(L"123") == 3, "failure");
//        static_assert(strlen(L"") == 0, "failure");
//    }


// [unit tests] meta-str

//    template <typename CharType, size_t N>
//    constexpr size_t len(const CharType (&str)[N])
//    {
//        return N - 1;
//    }
//
//
//    template <typename CharType, size_t N>
//    constexpr auto process_str(const CharType (&str)[N])
//    -> decltype(ct::meta_str(str))
//    {
//        return ct::meta_str(str);
//    }

//    static constexpr auto str_a  =  ct::meta_str("test");
//    static constexpr auto str_w  =  ct::meta_str(L"test");
//    static constexpr auto str1_a =  ct::create_meta_str("test1") + ct::meta_str("test2");
//    static constexpr auto str1_w =  ct::create_meta_str(L"test1") + ct::meta_str(L"test2");
//    static constexpr auto str2_a =  ct::meta_str("test1") + "test2";
//    static constexpr auto str2_w =  ct::meta_str(L"test1") + L"test2";
//    static constexpr auto str3_a =  "test2" + ct::meta_str("test1");
//    static constexpr auto str3_w =  L"test2" + ct::meta_str(L"test1");
//    static constexpr auto str4_a =  "test1" + ct::meta_str("test2") + "test3";
//    static constexpr auto str4_w =  L"test1" + ct::meta_str(L"test2") + L"test3";
//
//    static_assert(str_a.length == 4);
//    static_assert(str_a.c_str != nullptr);
//    static_assert(str4_a.length == str4_w.length);
//    static_assert(len(str4_a.c_str) == len(str4_w.c_str)); // use of compile-time functions with meta_str
//    static_assert(len(process_str("Test").c_str) == 4);
//    static_assert(len(process_str(L"Test").c_str) == 4);

//    static_assert(ct::meta_str("Test") == "Test");
//    static_assert("Test" == ct::meta_str("Test"));
//    static_assert(ct::create_meta_str("Test") == ct::meta_str("Test"));
//
//    static_assert(ct::meta_str(L"Test") == L"Test");
//    static_assert(L"Test" == ct::meta_str(L"Test"));
//    static_assert(ct::create_meta_str(L"Test") == ct::meta_str(L"Test"));

//    static_assert(ct::meta_str("Test")[2] == 's');

#endif
