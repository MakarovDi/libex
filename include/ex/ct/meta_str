#ifndef    EX_CT_META_STR_H
#   define EX_CT_META_STR_H


#include <iostream>
#include <cstdint>
#include "ex/meta"


//
// Usage (meta_str)
//
//  * for compile-time string concatenation:
//
//      static constexpr auto str = ct::create_meta_str("File: ") + ct::create_meta_str(__FILE__);
//      ...
//      std::cout << str << std::endl;
//      std::printf(str);
//
//  * for return compile-time string which can be used in compile-time function:
//
//       template <size_t N>
//       constexpr size_t strlen(const char (&str)[N])
//       {
//            return N - 1;
//       }
//
//
//       template <size_t N>
//       constexpr const char* strdup1(const char (&str)[N])
//       {
//           return str;
//       }
//
//
//       template <size_t N>
//       constexpr auto strdup2(const char (&str)[N])
//          -> decltype (ct::create_meta_str(str))
//       {
//          return ct::create_meta_str(str);
//       }
//
//
//       std::array<char, strlen(strdup1("Test"))>       a; // compilation error
//       std::array<char, strlen(strdup2("Test").c_str)> a; // ok
//
//
//  References:
//      doc/schurr_cpp11_tools_for_class_authors.pdf
//

// TODO: use decltype(auto) from C++14


namespace ex
{
namespace ct
{

    template<typename CharType, size_t... indexes>
    struct meta_str;


    template<typename CharType, size_t N, size_t... indexes>
    constexpr auto create_meta_str(const CharType (&str)[N], meta::integer_sequence<indexes...>)
        -> meta_str<CharType, indexes...>;


    namespace internal
    {
        template <size_t index, typename CharType, size_t N>
        constexpr CharType char_at(const CharType (&str)[N])
        {
            return str[index];
        }


        // unsafe: streq("Test", "Tst", 0) -> compilation error, streq("Test", "Test", 100) -> true
        template <typename CharType, size_t N>
        constexpr bool streq(const CharType (&str1)[N], const CharType (&str2)[N], size_t char_ofs)
        {
            return char_ofs >= N                    ? true  :
                   str1[char_ofs] != str2[char_ofs] ? false :
                   streq<CharType>(str1, str2, char_ofs + 1);
        }


        template <typename CharType, size_t N>
        constexpr bool streq(const CharType (&str1)[N], const CharType (&str2)[N])
        {
            return streq<CharType>(str1, str2, 0);
        }


        template <typename CharType, size_t N1, size_t N2>
        constexpr bool streq(const CharType (&str1)[N1], const CharType (&str2)[N2])
        {
            return false;
        }


        template <size_t offset, typename CharType, size_t N>
        constexpr auto substr(const CharType (&str)[N])
            -> decltype( create_meta_str(str, meta::make_integer_sequence<N-1, offset>{}) )
        {
            return create_meta_str(str, meta::make_integer_sequence<N-1, offset>{});
        }
    }



    template<typename CharType, size_t... indexes>
    struct meta_str
    {
        const CharType c_str[sizeof...(indexes) + 1];


        template <size_t N>
        constexpr meta_str(const CharType (&str)[N]) :
            c_str{ internal::char_at<indexes>(str)..., 0 }
        {
        }


        constexpr meta_str(meta::pack<CharType, indexes>... chars) :
            c_str{ chars..., 0 }
        {
        }


        constexpr meta_str(const meta_str& str) :
            c_str{ str.c_str[indexes]..., 0 }
        {
        }


        template <size_t offset>
        constexpr auto substr()
            -> decltype(internal::substr<offset>(c_str))
        {
            return internal::substr<offset>(c_str);
        }


        static constexpr size_t length = sizeof...(indexes);

        constexpr CharType operator[](size_t index) const { return c_str[index]; }
        constexpr operator const CharType* ()       const { return c_str;        }
    };


    // meta_str operators //


    template<typename CharType, size_t N, size_t... indexes>
    constexpr auto create_meta_str(const CharType (&str)[N], meta::integer_sequence<indexes...>)
        -> meta_str<CharType, indexes...>
    {
        return meta_str<CharType, indexes...>(str);
    }


    template<typename CharType, size_t N>
    constexpr auto create_meta_str(const CharType (& str)[N])
        -> decltype(create_meta_str(str, meta::make_integer_sequence<N - 1>{}))
    {
        return create_meta_str(str, meta::make_integer_sequence<N - 1>{});
    }


    template <typename CharType, size_t... indexes>
    std::basic_ostream<CharType>& operator<<(std::basic_ostream<CharType>& stream,
                                             const meta_str<CharType, indexes...>& str)
    {
        return stream << str.c_str;
    }


    template<typename CharType, size_t N1, size_t N2, size_t... indexes1, size_t... indexes2>
    constexpr auto strcat(const CharType (&str1)[N1],
                          const CharType (&str2)[N2],
                          meta::integer_sequence<indexes1...>,
                          meta::integer_sequence<indexes2...>)
        -> meta_str<CharType, indexes1..., sizeof...(indexes1) + indexes2...>
    {
        return { str1[indexes1]..., str2[indexes2]... };
    }


    template<typename CharType, size_t N1, size_t N2>
    constexpr auto strcat(const CharType (&str1)[N1], const CharType (&str2)[N2])
        -> decltype(strcat(str1, str2,
                           meta::make_integer_sequence<N1 - 1>(),
                           meta::make_integer_sequence<N2 - 1>()))
    {
        return strcat(str1, str2,
                      meta::make_integer_sequence<N1-1>(),
                      meta::make_integer_sequence<N2-1>());
    }


    template<typename CharType, size_t... indexes1, size_t... indexes2>
    constexpr auto operator+(meta_str<CharType, indexes1...> a,
                             meta_str<CharType, indexes2...> b)
        -> decltype(strcat(a.c_str, b.c_str))
    {
        return strcat(a.c_str, b.c_str);
    }


    template<typename CharType, size_t... indexes, size_t N>
    constexpr auto operator+(meta_str<CharType, indexes...> metastr, const CharType (&str)[N])
        -> decltype(metastr + create_meta_str(str))
    {
        return metastr + create_meta_str(str);
    }


    template<typename CharType, size_t... indexes, size_t N>
    constexpr auto operator+(const CharType (&str)[N], meta_str<CharType, indexes...> metastr)
        -> decltype(metastr + create_meta_str(str))
    {
        return create_meta_str(str) + metastr;
    }


    template<typename CharType, size_t... indexes1, size_t... indexes2>
    constexpr bool operator==(meta_str<CharType, indexes1...> metastr1, meta_str<CharType, indexes2...> metastr2)
    {
        return internal::streq(metastr1.c_str, metastr2.c_str);
    }

    template<typename CharType, size_t... indexes, size_t N>
    constexpr bool operator==(const CharType (&str)[N], meta_str<CharType, indexes...> metastr)
    {
        return internal::streq(str, metastr.c_str);
    }

    template<typename CharType, size_t... indexes, size_t N>
    constexpr bool operator==(meta_str<CharType, indexes...> metastr, const CharType (&str)[N])
    {
        return internal::streq(str, metastr.c_str);
    }

}
}

// [unit tests] meta-str

//    template <typename CharType, size_t N>
//    constexpr size_t len(const CharType (&str)[N])
//    {
//        return N - 1;
//    }
//
//
//    template <typename CharType, size_t N>
//    constexpr auto process_str(const CharType (&str)[N])
//    -> decltype(ct::create_meta_str(str))
//    {
//        return ct::create_meta_str(str);
//    }

//    static constexpr auto str_a  =  ct::create_meta_str("test");
//    static constexpr auto str_w  =  ct::create_meta_str(L"test");
//    static constexpr auto str1_a =  ct::create_meta_str("test1") + ct::create_meta_str("test2");
//    static constexpr auto str1_w =  ct::create_meta_str(L"test1") + ct::create_meta_str(L"test2");
//    static constexpr auto str2_a =  ct::create_meta_str("test1") + "test2";
//    static constexpr auto str2_w =  ct::create_meta_str(L"test1") + L"test2";
//    static constexpr auto str3_a =  "test2" + ct::create_meta_str("test1");
//    static constexpr auto str3_w =  L"test2" + ct::create_meta_str(L"test1");
//    static constexpr auto str4_a =  "test1" + ct::create_meta_str("test2") + "test3";
//    static constexpr auto str4_w =  L"test1" + ct::create_meta_str(L"test2") + L"test3";
//
//    static_assert(str_a.length == 4);
//    static_assert(str_a.c_str != nullptr);
//    static_assert(str4_a.length == str4_w.length);
//    static_assert(len(str4_a.c_str) == len(str4_w.c_str)); // use of compile-time functions with meta_str
//    static_assert(len(process_str("Test").c_str) == 4);
//    static_assert(len(process_str(L"Test").c_str) == 4);

//    static_assert(ct::create_meta_str("Test") == "Test");
//    static_assert("Test" == ct::create_meta_str("Test"));
//    static_assert(ct::create_meta_str("Test") == ct::create_meta_str("Test"));
//
//    static_assert(ct::create_meta_str(L"Test") == L"Test");
//    static_assert(L"Test" == ct::create_meta_str(L"Test"));
//    static_assert(ct::create_meta_str(L"Test") == ct::create_meta_str(L"Test"));

//    static_assert(ct::create_meta_str("Test")[2] == 's');


#endif
